
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Perp Scan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      color-scheme: dark;
      --bg: #000000;            /* Pure black background */
      --card: #0d0d0d;          /* Slightly lifted card background */
      --border: #1a1a1a;        /* Subtle card borders */
      --muted: #6b6b6b;         /* Muted gray text */
      --text: #dcdcdc;          /* Soft off-white text */
      --pill-bg: #111111;       /* Dark pill buttons */
      --pill-text: #e5e5e5;
      --success: #3be879;       /* Bright neon green */
      --danger: #ff5555;        /* Clean red */
      --radius-lg: 14px; 
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text","Segoe UI", sans-serif;
      min-height: 100vh;
      background: #000000;              /* pure black */
      color: var(--text);
      display: flex;
      justify-content: center;
      padding: 24px;
      padding-top: 80px;
    }
    .app {
      width: 100%;
      max-width: 1400px;
    }
    .topbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 64px;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 16px;
      padding: 0 24px;
      backdrop-filter: blur(10px);
      background: rgba(0, 0, 0, 0.25);
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      z-index: 9999;
    }
    .topbar-form {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .topbar-form input {
      width: 260px;            /* tighter width for header */
    }
    .topbar-logo {
      height: 40px;
      width: 40px;
      object-fit: contain;
      cursor: pointer;
    }
    .topbar-title {
      font-size: 1.15rem;
      font-weight: 650;
      color: #e5e5e5;
      cursor: pointer;
      margin-right: auto; 
    }
    .topbar-title:hover {
      color: #ffffff;
    }
    /* ---------- HOME SEARCH BAR (landing page) ---------- */
    .home-search {
      margin-top: 16px;
      display: flex;
      gap: 12px;
      justify-content: flex-start;    /* left aligned */
      align-items: center;
    }
    .home-search input {
      width: 440px;                   /* üëà fits a full HL address */
      max-width: 100%;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #050505;
      color: var(--text);
      font-size: 0.9rem;
    }
    .home-search button {
      padding: 10px 18px;
      border-radius: 999px;
      background: #111111;
      border: 1px solid var(--border);
      color: var(--text);
      font-size: 0.9rem;
      font-weight: 550;
      cursor: pointer;
    }
    .home-search button:hover {
      background: #1a1a1a;
      color: #ffffff;
    }

    .app header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 18px;
    }
    .tag {
      padding: 4px 9px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.35);
      font-size: 0.72rem;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .tag-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #dcdcdc; /* soft white */
      box-shadow: none;
    }
    .card {
      background: var(--card);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
      padding: 18px 18px 14px;
      margin-bottom: 16px;
      box-shadow: none;
    }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 10px;
      gap: 10px;
    }
    .card-title {
      font-size: 0.92rem;
      font-weight: 550;
    }
    .card-sub {
      font-size: 0.78rem;
      color: var(--muted);
    }
    input, select {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #050505;
      color: var(--text);
      padding: 7px 11px;
      font-size: 0.82rem;
      outline: none;
      transition: border-color 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
    }
    input::placeholder {
      color: #6b6b6b; /* softer muted gray */
    }
    input:focus,
    select:focus {
      border-color: #ffffff;      /* white border on focus */
      box-shadow: none;           /* no glow */
      background: #050505;        /* stays dark */
      color: var(--text);         /* keep visible text */
    }
    button {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 10px 18px;
      font-size: 0.86rem;
      font-weight: 550;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 7px;
      background: #111111;          /* flat dark button */
      color: var(--text);
      box-shadow: none;             /* NO glow */
      white-space: nowrap;
      transition: background 0.12s ease, color 0.12s ease;
    }

    button:hover {
      background: #1a1a1a;          /* subtle brightening */
      color: #ffffff;
    }

    button:active {
      background: #0c0c0c;
      color: #e5e5e5;
    }
    button[disabled] {
      opacity: 0.6;
      cursor: default;
      box-shadow: none;
      transform: none;
    }
    .status {
      font-size: 0.78rem;
      color: var(--muted);
      margin-top: 8px;
      min-height: 18px;
    }
    .status-error { color: var(--danger); }
    .status-ok { color: var(--success); }
    .grid-2 {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 16px;
    }
    .mini-label {
      font-size: 0.78rem;
      color: var(--muted);
      margin-bottom: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    .summary-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .badge {
      padding: 3px 8px;
      border-radius: 999px;
      font-size: 0.74rem;
      border: 1px solid var(--border);
      background: #050505;
      color: var(--muted);
      display: inline-flex;
      gap: 6px;
      align-items: baseline;
    }
    .badge-strong {
      color: var(--text);
      font-weight: 540;
    }
    .pill-green { color: var(--success); }
    .pill-red { color: var(--danger); }

    /* ---------- TABLES ---------- */
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      margin-top: 4px;
      color: var(--text);
      background: transparent !important;   /* no table fill */
    }

    th, td {
      padding: 10px 12px;            /* EVEN column spacing */
      text-align: left;
      border-bottom: 1px solid #111111;
    }

    th {
      font-size: 0.8rem;             /* larger header text */
      font-weight: 550;
      color: #c7c7c7;                /* brighter header */
      background: #050505;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    td {
      color: #e6e6e6;
    }

    /* -------- CLEAN TABLE THEME (matches chart background) -------- */

    /* Remove header box fill */
    table thead th {
      background: transparent !important;
      border-bottom: 1px solid #1a1a1a;     /* subtle bottom line */
    }
    /* Rows: no fill, only separators */
    table tbody tr {
      background: transparent !important;
    }
    table td {
      border-bottom: 1px solid #111111;     /* subtle separators */
    }
    /* Hover: tiny brightness bump */
    table tbody tr:hover td {
      background: rgba(255, 255, 255, 0.02) !important;
    }

    .table-wrap {
      border: none !important;             /* üî• remove the outer box completely */
      border-radius: 0 !important;
      background: transparent !important;
      overflow: visible !important;        /* üî• prevents cut edges */
      padding: 0;                          /* ensure no forced box look */
      margin: 0;
    }
    .table-inner-scroll {
      max-height: 360px;
      overflow: auto;
      background: transparent !important;    /* NEW */
    }

    .raw-json {
      margin-top: 8px;
      font-size: 0.74rem;
      background: #050505;                 /* darker neutral */
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 8px 10px;
      overflow: auto;
      max-height: 260px;
      color: var(--muted);
    }

    summary { cursor: pointer; user-select: none; }

    /* ---------- TABLE TABS (match range buttons) ---------- */

    /* INACTIVE tab (same as inactive range button) */
    .tab-pill {
      border-radius: 999px;
      border: none;
      background: transparent;
      padding: 8px 18px;            /* ‚Üë bigger pill */
      font-size: 0.94rem;           /* ‚Üë bigger text */
      color: var(--muted);
      cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease;
    }
    /* HOVER effect (same as range buttons) */
    .tab-pill:hover:not(.tab-pill-active) {
      background: rgba(255,255,255,0.05);
      color: var(--text);
    }
    /* ACTIVE tab (match All / 90D active styling) */
    .tab-pill-active {
      background: #ffffff10;               /* subtle white tint */
      color: #ffffff;                      /* bright text */
    }
    .tab-count {
      font-size: 0.72rem;
      opacity: 0.8;
    }
    .range-row {
      display: inline-flex;
      gap: 6px;
      padding: 4px;
      border-radius: 999px;
      background: #050505;
      border: 1px solid var(--border);
    }
    .range-btn {
      border-radius: 999px;
      border: none;
      background: transparent;
      padding: 4px 10px;
      font-size: 0.74rem;
      color: var(--muted);
      cursor: pointer;
    }
    .range-btn-active {
      background: #ffffff10;     /* subtle white tint */
      color: #ffffff;            /* white text */
    }

    .chart-header-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px;
    }
      .chart-live-value {
        font-size: 0.82rem;
        font-weight: 500;
        color: var(--muted);          /* grey, like axis labels */
      }
      /* This wraps JUST the number */
      .chart-live-number {
        margin-left: 4px;
      }
      /* Color only the number span, not any parent */
      .chart-live-number.chart-live-positive {
        color: var(--success);
      }
      .chart-live-number.chart-live-negative {
        color: var(--danger);
      }

    /* ---------- CHART CONTAINERS ---------- */
    #equityChartContainer {
      position: relative;
      width: 100%;
      height: 220px;
      margin-top: 8px;
      background: transparent; /* no darker panel */
    }

    /* Top row: Portfolio snapshot (left) + Perp chart (right) */
    .top-row {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr); /* 50/50 split */
      gap: 16px;
      margin-bottom: 16px;
    }

    /* Make sure cards stretch nicely inside the row */
    .top-row .card {
      height: 100%;
    }

    /* On smaller screens, stack vertically */
    @media (max-width: 900px) {
      .top-row {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    @media (max-width: 840px) {
      body { padding: 12px; }
      /* header { ... }  ‚Üê remove this line */
      button { justify-content: center; width: 100%; }
      .grid-2 { grid-template-columns: minmax(0, 1fr); }
      .tabs-row { width: 100%; justify-content: space-between; flex-wrap: wrap; }
      .range-row { margin-top: 8px; }
    }

  </style>
</head>
<body>
<header class="topbar">
  <img src="./assets/PSLOGO.png" class="topbar-logo" onclick="window.location.href='/'">
  <span class="topbar-title" onclick="window.location.href='/'">Perp Scan</span>

  <!-- üîπ Right-aligned search bar -->
  <form id="query-form" class="topbar-form">
    <input id="account" name="account" type="text" placeholder="0x‚Ä¶ / address" required />
    <button id="fetchBtn" type="submit">Search</button>
  </form>
</header>
<div class="app">

<main>
  <section class="card">
    <div class="card-header">
      <div>
        <div class="card-title" id="hero-title">Scan a Hyperliquid account</div>

        <!-- Home page search bar -->
        <div id="home-search-bar" class="home-search" style="display:none;">
          <input id="homeAccount" type="text" placeholder="Paste address‚Ä¶">
          <button id="homeSearchBtn">Search</button>
        </div>
      </div>
    </div>

    <!-- üîπ Summary + cashflows now live in the top card -->
    <div class="grid-2" id="detail-summary-row" style="margin-top:12px; display:none;">
      <div>
        <div class="mini-label">
          <span>Summary</span>
          <span id="accountLabel" style="font-size:0.75rem;"></span>
        </div>
        <div id="summaryBadges" class="summary-badges"></div>
      </div>
      <div>
        <div class="mini-label"><span>Cashflows / meta</span></div>
        <div id="summaryMeta" class="summary-badges"></div>
      </div>
    </div>

    <div id="status" class="status"></div>
  </section>
  <!-- ... rest of your main sections ... -->

           <!-- NEW TOP ROW: snapshot (left) + chart (right) -->
      <div class="top-row">

      <!-- LEFT: Perp ROE + Directional bias -->
      <section class="card" id="summary-card" style="display:none; height:100%;">
      
        <!-- ROE header -->
        <div class="card-header">
          <div>
            <div class="card-title">Perp ROE</div>
            <div class="card-sub" id="roeRangeLabel">Return on equity for this window.</div>
          </div>
        </div>
      
        <!-- ROE section -->
        <div style="display:flex; flex-direction:column; gap:10px; margin-bottom:12px;">
          <div id="roeValue"
               style="font-size:1.6rem; font-weight:600; color:var(--muted);">
            --
          </div>
          <div id="roeMeta"
               style="font-size:0.78rem; color:var(--muted);">
            Uses perp account value at the start and end of the selected timeframe.
          </div>
        </div>

        <!-- === [FE BLOCK #2 ‚Äî Winrate UI FINAL] ================= -->
        <div style="margin-top:6px; margin-bottom:10px;">
          <div class="mini-label" style="color:#ffffff !important;">
            <span style="font-weight:600;">Winrate</span>
          </div>
        
          <div style="
                display:flex;
                justify-content:space-between;
                align-items:center;
                margin-top:4px;
                font-size:1.0rem;
                color:#ffffff;
              ">
            <!-- Value: same visual weight as ROE, no muted gray -->
            <span id="winrateValue" style="font-weight:600; color:#ffffff;">
              --
            </span>
        
            <!-- Meta: can stay slightly softer -->
            <span id="winrateMeta" style="font-size:0.78rem; color:var(--muted);">
              (0 trades)
            </span>
          </div>
        </div>
      
        <!-- DIRECTIONAL BIAS (closed trades) -->
        <div class="mini-label" style="margin-top:10px;">
          <span>Directional bias (closed)</span>
        </div>
      
        <!-- Bar -->
        <div id="directionalBiasBar"
             style="
               margin-top:4px;
               height:8px;
               border-radius:999px;
               overflow:hidden;
               background:#111;
             ">
          <div id="directionalBiasLong"
               style="
                 height:100%;
                 float:left;
                 width:50%;
                 background:var(--success);
               "></div>
          <div id="directionalBiasShort"
               style="
                 height:100%;
                 float:left;
                 width:50%;
                 background:var(--danger);
               "></div>
        </div>
      
        <!-- Labels under bar -->
        <div style="
              display:flex;
              justify-content:space-between;
              margin-top:4px;
              font-size:0.78rem;
            ">
          <span id="directionalBiasLongLabel">Long --%</span>
          <span id="directionalBiasShortLabel">Short --%</span>
        </div>
      
        <!-- Meta -->
        <div id="directionalBiasMeta"
             style="font-size:0.74rem; color:var(--muted); margin-top:5px;">
          No fully closed trades in this period.
        </div>
      
      </section>

        <!-- RIGHT: Perp PnL / balance chart -->
        <section class="card" id="chart-card" style="display:none;">
          <div class="card-header">
            <!-- LEFT SIDE -->
            <div>
              <div class="tabs-row" id="chart-mode-tabs">
                <button type="button"
                        class="tab-pill tab-pill-active"
                        id="chart-tab-pnl"
                        data-chart="pnl">
                  <span>Perp PnL</span>
                </button>
                <button type="button"
                        class="tab-pill"
                        id="chart-tab-balance"
                        data-chart="balance">
                  <span>Perp balance</span>
                </button>
              </div>
              <div class="card-sub" id="chart-subtitle">
                Realized + funding PnL for this window.
              </div>
            </div>

            <!-- RIGHT SIDE -->
            <div class="chart-header-right">
              <div class="range-row">
                <button type="button" class="range-btn range-btn-active" data-range="all">All</button>
                <button type="button" class="range-btn" data-range="90d">90D</button>
                <button type="button" class="range-btn" data-range="30d">30D</button>
                <button type="button" class="range-btn" data-range="7d">7D</button>
                <button type="button" class="range-btn" data-range="1d">1D</button>
              </div>

              <div id="chart-live-value" class="chart-live-value"></div>
            </div>
          </div>

          <div id="equityChartContainer">
            <canvas id="equityChart"></canvas>
          </div>
        </section>

      </div> <!-- end .top-row -->

      <section class="card" id="tables-card" style="display:none;">
        <div class="card-header">
          <div>
            <div class="card-title">Account tables</div>
            <div class="card-sub">One full-width table at a time ‚Äî positions, closed trades, or cashflows.</div>
          </div>
        </div>

        <div class="tabs-row">
          <button type="button" class="tab-pill tab-pill-active" id="tab-positions">
            <span>Open positions</span>
            <span class="tab-count" id="positionsCount">(0)</span>
          </button>
          <button type="button" class="tab-pill" id="tab-closed">
            <span>Closed trades</span>
            <span class="tab-count" id="closedCount">(0)</span>
          </button>
          <button type="button" class="tab-pill" id="tab-orders">
            <span>Open orders</span>
            <span class="tab-count" id="ordersCount">(0)</span>
          </button>
          <button type="button" class="tab-pill" id="tab-cash">
            <span>Deposits / withdrawals</span>
            <span class="tab-count" id="cashCount">(0)</span>
          </button>
        </div>

        <div class="mini-label" style="margin-top:8px;">
          <span id="activeTableTitle">Open positions</span>
        </div>

        <div class="table-wrap">
          <div class="table-inner-scroll" id="positionsBlock">
            <div id="positionsTableContainer" style="padding:10px; font-size:0.78rem; color:var(--muted);">
              No positions yet. Run a search above.
            </div>
          </div>
          <div class="table-inner-scroll" id="closedBlock" style="display:none;">
            <div id="closedTableContainer" style="padding:10px; font-size:0.78rem; color:var(--muted);">
              No trades yet. Run a search above.
            </div>
          </div>
          <div class="table-inner-scroll" id="ordersBlock" style="display:none;">
            <div id="ordersTableContainer" style="padding:10px; font-size:0.78rem; color:var(--muted);">
              No open orders yet. Run a search above.
            </div>
          </div>
          <div class="table-inner-scroll" id="cashBlock" style="display:none;">
            <div id="cashTableContainer" style="padding:10px; font-size:0.78rem; color:var(--muted);">
              No deposits or withdrawals yet. Run a search above.
            </div>
          </div>
        </div>

        <details class="raw-json" id="rawJsonBlock" style="display:none;">
          <summary>Show raw JSON response</summary>
          <pre id="rawJson"></pre>
        </details>
      </section>
    </main>
  </div>

<script>
  let activeTab = "positions";
  let equitySeriesAll = [];
  let pnlSeriesAll = [];
  let equityChart = null;
  let currentRange = "all";      // UI range: all, 90d, 30d, 7d, 1d
  let activeChartMode = "pnl";   // "pnl" or "balance"

    // üîπ Funding pagination state (ADD THIS)
  let fundingEventsAll = [];     // full list from Worker
  const DEFAULT_BASE_URL = "https://perp-scan-live.liam-alerts.workers.dev";

function renderFundingTable(container) {
  if (!container) return;

  // Use the full list, no pagination
  const list = Array.isArray(fundingEventsAll) ? fundingEventsAll : [];

  const table = document.createElement("table");
  table.className = "data-table";

  const thead = document.createElement("thead");
  thead.innerHTML = `
    <tr>
      <th>Date / Time</th>
      <th>Type</th>
      <th>Amount (USDC)</th>
      <th>Note</th>
    </tr>
  `;
  table.appendChild(thead);

  const tbody = document.createElement("tbody");

  if (!list.length) {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td colspan="4" class="muted">
        No deposits or withdrawals found.
      </td>`;
    tbody.appendChild(tr);
  } else {
    for (const ev of list) {
      if (!ev) continue;

      const ts   = Number(ev.time || ev.ts || 0);
      const amt  = Number(ev.usdcValue || ev.amount || 0);
      const note = ev.note || "";

      const type       = amt >= 0 ? "Deposit" : "Withdrawal";
      const colorClass = amt >= 0 ? "pill-green" : "pill-red";

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${ts ? formatDateTime(ts) : ""}</td>
        <td>${type}</td>
        <td class="${colorClass}">
          ${amt >= 0 ? "+" : "-"}$${formatNumber(Math.abs(amt), 2)}
        </td>
        <td>${note}</td>
      `;
      tbody.appendChild(tr);
    }
  }

  table.appendChild(tbody);
  container.innerHTML = "";
  container.appendChild(table);
}

  // Lightweight app state (Plan A step)
  const appState = {
    account: null,
    period: "all",   // UI range: all / 90d / 30d / 7d / 1d
    data: null,      // last /pnlClean response
  };

  function formatNumber(x, decimals = 2) {
    if (x === null || x === undefined || isNaN(Number(x))) return "";
    const n = Number(x);
    const opts = { minimumFractionDigits: decimals, maximumFractionDigits: decimals };
    return n.toLocaleString(undefined, opts);
  }

    function formatTokenPrice(raw) {
      const n = Number(raw);
      if (!Number.isFinite(n) || n === 0) return "";
    
      const abs = Math.abs(n);
      const intPart = Math.floor(abs);
    
      let decimals;
    
      // --- HIGH PRICE ASSETS (‚â•10) ‚Üí FIXED 2 DECIMALS ---
      if (intPart >= 10) {
        decimals = 2;
    
      // --- MID RANGE (1‚Äì9.9) ‚Üí 3 DECIMALS ---
      } else if (abs >= 1) {
        decimals = 3;
    
      // --- SMALL TOKENS (<1) ‚Üí more precision ---
      } else if (abs >= 0.1) {
        decimals = 4;
      } else if (abs >= 0.01) {
        decimals = 5;
      } else {
        decimals = 6;
      }
    
      return n.toFixed(decimals);
    }

  function createBadge(label, value, options = {}) {
    if (value === null || value === undefined || value === "") return null;

    const badge = document.createElement("div");
    badge.className = "badge";

    const labelSpan = document.createElement("span");
    labelSpan.textContent = label;

    const valueSpan = document.createElement("span");
    valueSpan.className = "badge-strong";

    if (options.color === "green") valueSpan.classList.add("pill-green");
    if (options.color === "red") valueSpan.classList.add("pill-red");

    valueSpan.textContent = value;

    // Optional tooltip (e.g. start/end equity)
    if (options.title) {
      badge.title = options.title;
    }

    badge.appendChild(labelSpan);
    badge.appendChild(valueSpan);
    return badge;
  }

  function humanizeDuration(ms) {
    if (ms == null || isNaN(ms)) return "";
    const s = Math.max(0, Math.floor(ms / 1000));
    const days = Math.floor(s / 86400);
    const hours = Math.floor((s % 86400) / 3600);
    const mins = Math.floor((s % 3600) / 60);
    const secs = s % 60;

    const parts = [];
    if (days) parts.push(days + "d");
    if (hours) parts.push(hours + "h");
    if (mins) parts.push(mins + "m");
    if (!days && !hours && !mins) parts.push(secs + "s");
    return parts.join(" ");
  }

  function formatDateTime(ts) {
    if (!ts && ts !== 0) return "";
    const d = new Date(ts);
    return d.toLocaleString("en-GB", {
      day: "numeric",      // üëà no leading zero
      month: "short",
      hour: "2-digit",
      minute: "2-digit",
      hourCycle: "h23",
    }).replace(",", "");
  }

  function buildSlTpByCoin(positions, openOrders) {
  const posMap = {};
  positions.forEach(p => {
    if (!p || !p.coin) return;
    posMap[p.coin] = p;
  });

  // Filter only exit orders
  const exits = (openOrders || []).filter(o =>
    o && (o.reduceOnly === true || o.isPositionTpsl === true)
  );

  const out = {};

  exits.forEach(o => {
    const coin = o.coin;
    const pos = posMap[coin];
    if (!pos) return;

    const mark = pos.markPx || pos.indexPx || pos.entryPx;
    const px = o.isTrigger ? o.triggerPx : o.px;

    const sz = Math.abs(Number(o.sz ?? o.size ?? 0));
    if (!Number.isFinite(sz) || !Number.isFinite(px)) return;

    const isLong = pos.side?.toLowerCase() === "long";
    const isSell = o.side === "a" || o.side === "sell";
    const isBuy  = o.side === "b" || o.side === "buy";

    let kind = "UNKNOWN";

    if (isLong) {
      if (isSell && px > mark) kind = "TP";
      else if (isSell && px < mark) kind = "SL";
    } else {
      if (isBuy && px > mark) kind = "SL";
      else if (isBuy && px < mark) kind = "TP";
    }

    if (!out[coin]) out[coin] = { position: pos, tps: [], sls: [] };

    if (kind === "TP") out[coin].tps.push({ ...o, px, sz });
    if (kind === "SL") out[coin].sls.push({ ...o, px, sz });
  });

  return out;
}

  function normalizeTs(v) {
  if (typeof v === "string") {
    // remove commas in things like "1,762,096,363,016"
    const cleaned = v.replace(/,/g, "");
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : null;
  }
  return Number.isFinite(v) ? v : null;
}

function buildTable(container, rows, opts = {}) {
  container.innerHTML = "";
  if (!Array.isArray(rows) || rows.length === 0) {
    container.innerHTML =
      '<div style="padding:10px; font-size:0.78rem; color:var(--muted);">No data returned.</div>';
    return;
  }

  const isPositions = opts.type === "positions";
  const isClosed    = opts.type === "closed";
  const nowMs       = typeof opts.nowMs === "number" ? opts.nowMs : Date.now();

  // üîπ For positions, compute durationMs from entryTs if not present
  if (isPositions) {
    rows = rows.map((row) => {
      if (!row || typeof row !== "object") return row;
      const r = { ...row };

      if (typeof r.durationMs !== "number" && typeof r.entryTs === "number") {
        const ageMs = nowMs - r.entryTs;
        if (Number.isFinite(ageMs) && ageMs > 0) {
          r.durationMs = ageMs;
        }
      }

      return r;
    });
  }

  const displayNames = isPositions
    ? {
        coin: "Asset",
        side: "Direction",
        value: "Position Value / Size",
        fullTpSl: "TP/SL price",
        entryPx: "Entry Price",
        markPx: "Current Price",
        unrealizedPnl: "Unrealized PnL",
        entryTs: "Entry Date",
        durationMs: "Duration",
      }
    : isClosed
    ? {
        netPnl: "Net PnL",
        sizeClosed: "Size Closed",
        avgEntryPx: "Entry Price",
        exitPx: "Exit Price",
        entryTs: "Entry Date",
        durationMs: "Duration",
      }
    : {};

  const hidden = isPositions
    ? new Set([
        "coinIdx",
        "notional",
        "basisPct",
        "unrealizedPct",
        "roiPct",
        "roePct",
        "leverage", // inline into Direction
        "size",     // inline under Position Value
      ])
    : isClosed
    ? new Set([
        "endTs",
        "pnl",
        "pnlUsd",
        "startTs",   // üî• hide start timestamp
        "openTs",    // üî• hide alternate HL entry timestamp if present
      ])
    : new Set([]);

  let keys = Object.keys(rows[0] || {}).filter((k) => {
    const v = rows[0][k];
    if (typeof v === "object" || typeof v === "function") return false;
    if (hidden.has(k)) return false;
    return true;
  });

  // üîπ Column ordering tweaks for positions
  if (isPositions) {
    // Ensure value comes right after side
    const idxSide  = keys.indexOf("side");
    const idxValue = keys.indexOf("value");
    if (idxSide !== -1 && idxValue !== -1 && idxValue !== idxSide + 1) {
      keys.splice(idxValue, 1);
      keys.splice(idxSide + 1, 0, "value");
    }

    // Ensure entryTs comes before duration
    const idxEntry = keys.indexOf("entryTs");
    const idxDur   = keys.indexOf("durationMs");
    if (idxEntry !== -1 && idxDur !== -1 && idxEntry > idxDur) {
      keys.splice(idxEntry, 1);
      keys.splice(idxDur, 0, "entryTs");
    }

    // Put duration at the end
    const idxDuration = keys.indexOf("durationMs");
    if (idxDuration !== -1) {
      keys.splice(idxDuration, 1);
      keys.push("durationMs");
    }

    // üîπ INSERT: Full TP/SL column after "side"
    if (!keys.includes("fullTpSl")) {
      const idxSide2 = keys.indexOf("side");
      if (idxSide2 !== -1) {
        keys.splice(idxSide2 + 1, 0, "fullTpSl");
      }
    }
  }

  // üîπ Column ordering + entry date support for CLOSED trades
  if (isClosed) {
    // If backend doesn't send entryTs but does send startTs/openTs etc,
    // we still want an "Entry Date" column.
    const hasEntryTsKey   = keys.includes("entryTs");
    const hasEntryTsValue = rows.some((r) =>
      r &&
      (
        typeof r.entryTs === "number" ||
        typeof r.startTs === "number" ||
        typeof r.openTs  === "number" ||
        typeof r.entryTs === "string" ||
        typeof r.startTs === "string" ||
        typeof r.openTs  === "string"
      )
    );

    if (!hasEntryTsKey && hasEntryTsValue) {
      const idxDur = keys.indexOf("durationMs");
      if (idxDur === -1) {
        keys.push("entryTs");
      } else {
        keys.splice(idxDur, 0, "entryTs");
      }
    }

    // Ensure entryTs comes before durationMs
    const idxEntry = keys.indexOf("entryTs");
    const idxDur   = keys.indexOf("durationMs");
    if (idxEntry !== -1 && idxDur !== -1 && idxEntry > idxDur) {
      keys.splice(idxEntry, 1);
      keys.splice(idxDur, 0, "entryTs");
    }

    // Put durationMs at the end
    const idxDuration = keys.indexOf("durationMs");
    if (idxDuration !== -1) {
      keys.splice(idxDuration, 1);
      keys.push("durationMs");
    }
  }

  if (!keys.length) {
    container.innerHTML =
      '<div style="padding:10px; font-size:0.78rem; color:var(--muted);">Unsupported row format.</div>';
    return;
  }

  const table  = document.createElement("table");
  const thead  = document.createElement("thead");
  const trHead = document.createElement("tr");

  keys.forEach((key) => {
    const th = document.createElement("th");
    th.textContent = displayNames[key] || key;
    trHead.appendChild(th);
  });
  thead.appendChild(trHead);
  table.appendChild(thead);

  const tbody = document.createElement("tbody");

  rows.forEach((r) => {
    const tr = document.createElement("tr");

    keys.forEach((k) => {
      const td = document.createElement("td");
      let v = r[k];

      // --- Single full-exit TP/SL price only (positions) ---
      if (isPositions && k === "fullTpSl") {
        const entry = opts.slTpByCoin?.[r.coin];
        let text = "";

        if (entry) {
          const posSize = Math.abs(Number(r.size));

          if (Number.isFinite(posSize) && posSize > 0) {
            const threshold = posSize;

            const getOrderSize = (o) => {
              const raw = o.sz ?? o.size;
              const n   = Number(raw);
              return Number.isFinite(n) ? Math.abs(n) : 0;
            };

            const qualifyingTps = entry.tps.filter((o) => getOrderSize(o) >= threshold);
            const qualifyingSls = entry.sls.filter((o) => getOrderSize(o) >= threshold);

            const tpOrder = qualifyingTps.length === 1 ? qualifyingTps[0] : null;
            const slOrder = qualifyingSls.length === 1 ? qualifyingSls[0] : null;

            const formatPx = (o) => {
              const isTrigger = o.isTrigger === true;
              let raw;
              if (isTrigger) {
                raw = o.triggerPx;
              } else {
                raw = o.px ?? o.price;
              }
              const formatted = formatTokenPrice(raw);
              return formatted;
            };

            const parts = [];
            if (tpOrder) {
              const px = formatPx(tpOrder);
              if (px) parts.push(`TP $${px}`);
            }
            if (slOrder) {
              const px = formatPx(slOrder);
              if (px) parts.push(`SL $${px}`);
            }

            text = parts.join(" | ");
          }
        }

        td.textContent = text;
        tr.appendChild(td);
        return;
      }

      // üîπ Entry date formatting (positions + closed trades)
      if ((isPositions || isClosed) && k === "entryTs") {
        let ts =
          normalizeTs(v) ??
          normalizeTs(r.entryTs) ??
          normalizeTs(r.startTs) ??
          normalizeTs(r.openTs);

        td.textContent = ts ? formatDateTime(ts) : "";
        tr.appendChild(td);
        return;
      }

      // üîπ Direction (positions): "Long - 5x"
      if (isPositions && k === "side") {
        const sideText = v == null ? "" : String(v);
        const lev      = typeof r.leverage === "number" ? r.leverage : null;
        td.textContent = lev ? `${sideText} - ${lev}x` : sideText;

      // üîπ Position Value cell: main value + size underneath
      } else if (isPositions && k === "value") {
        const main =
          typeof v === "number"
            ? "$" + formatNumber(v, 2)
            : v == null
            ? ""
            : String(v);

        const sz   = typeof r.size === "number" ? r.size : null;
        const coin = r.coin ? String(r.coin).toUpperCase() : "";
        const sub =
          sz != null
            ? `${formatNumber(sz, 2)}${coin ? " " + coin : ""}`
            : "";

        td.innerHTML = sub
          ? `<div>${main}</div>
             <div style="font-size:0.78rem; color: var(--muted); margin-top:2px;">${sub}</div>`
          : `<div>${main}</div>`;

      } else if (typeof v === "number") {
        // üîπ Duration (both open + closed)
        if (k === "durationMs") {
          td.textContent = humanizeDuration(v);

        // üîπ unrealizedPnl + roePct ‚Üí "-$2,870.69 (-51.78%)"
        } else if (k === "unrealizedPnl") {
          const sign     = v >= 0 ? "" : "-";
          const baseText = sign + "$" + formatNumber(Math.abs(v), 2);

          const roe = typeof r.roePct === "number" ? r.roePct : null;
          let roeText = "";
          if (roe !== null) {
            const pctSign = roe >= 0 ? "" : "-";
            roeText = ` (${pctSign}${formatNumber(Math.abs(roe), 2)}%)`;
          }

          td.textContent = baseText + roeText;

          if (v > 0) td.style.color = "var(--success)";
          if (v < 0) td.style.color = "var(--danger)";

        // üîπ Price-like fields
        } else if (
          k === "entryPx" ||
          k === "markPx" ||
          k === "avgEntryPx" ||
          k === "exitPx"
        ) {
          const pxText = formatTokenPrice(v);
          td.textContent = pxText ? "$" + pxText : "";

        // üîπ All other numeric fields
        } else {
          td.textContent = formatNumber(v, 2);
        }

      } else {
        td.textContent = v == null ? "" : String(v);
      }

      tr.appendChild(td);
    });

    tbody.appendChild(tr);
  });

  table.appendChild(tbody);
  container.appendChild(table);
}

function renderCashflowsTable(container, cashflows) {
  container.innerHTML = "";

  const list = Array.isArray(cashflows) ? cashflows : [];

  if (!list.length) {
    container.innerHTML = `
      <div style="padding:10px; font-size:0.78rem; color:var(--muted);">
        No deposits or withdrawals in this period.
      </div>
    `;
    return;
  }

  // Sort newest ‚Üí oldest if possible
  const sorted = [...list].sort((a, b) => {
    const ta = Number(a.ts ?? a.time ?? 0);
    const tb = Number(b.ts ?? b.time ?? 0);
    return tb - ta;
  });

  const table = document.createElement("table");
  table.innerHTML = `
    <thead>
      <tr>
        <th>Date / Time</th>
        <th>Direction</th>
        <th>Amount (USDC)</th>
        <th>Asset</th>
        <th>Note</th>
      </tr>
    </thead>
  `;
  const tbody = document.createElement("tbody");

  sorted.forEach((cf) => {
    if (!cf) return;

    const kindRaw = (cf.kind || "").toLowerCase();

    const amtRaw = Number(
      cf.usd ??
      cf.usdc ??
      cf.amountUsd ??
      cf.amount_usd ??
      cf.amount ??
      0
    );

    let direction = "Transfer";
    let dirColor  = "var(--muted)";
    let signed    = amtRaw;

    if (kindRaw.includes("deposit")) {
      direction = "Deposit";
      dirColor  = "var(--success)";
      signed    = Math.abs(amtRaw);
    } else if (kindRaw.includes("withdraw")) {
      direction = "Withdrawal";
      dirColor  = "var(--danger)";
      signed    = -Math.abs(amtRaw);
    } else {
      if (amtRaw > 0) {
        direction = "Deposit";
        dirColor  = "var(--success)";
        signed    = amtRaw;
      } else if (amtRaw < 0) {
        direction = "Withdrawal";
        dirColor  = "var(--danger)";
        signed    = amtRaw;
      }
    }

    const ts    = cf.ts ?? cf.time ?? null;
    const asset = cf.asset || cf.coin || "USDC";
    const note  = cf.note || cf.memo || "";

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${ts ? formatDateTime(ts) : ""}</td>
      <td style="color:${dirColor};">${direction}</td>
      <td style="color:${dirColor};">
        ${signed >= 0 ? "+" : "-"}$${formatNumber(Math.abs(signed), 2)}
      </td>
      <td>${asset}</td>
      <td>${note}</td>
    `;
    tbody.appendChild(tr);
  });

  table.appendChild(tbody);
  container.appendChild(table);
}
  
    function renderOpenOrders(openOrders) {
      const container = document.getElementById("ordersTableContainer");
      const countSpan = document.getElementById("ordersCount");
      if (!container || !countSpan) return;
    
      if (!openOrders || openOrders.error) {
        container.innerHTML = `
          <div style="padding:10px; font-size:0.78rem; color:var(--muted);">
            No open orders.
          </div>`;
        countSpan.textContent = "(0)";
        return;
      }
    
      const list = Array.isArray(openOrders) ? openOrders : [];
      countSpan.textContent = `(${list.length})`;
    
      if (list.length === 0) {
        container.innerHTML = `
          <div style="padding:10px; font-size:0.78rem; color:var(--muted);">
            No open orders yet.
          </div>`;
        return;
      }
    
      let html = `
        <table>
          <thead>
            <tr>
              <th>Coin</th>
              <th>Side</th>
              <th>Price</th>
              <th>Size</th>
              <th>Order Value</th>
              <th>Placed</th>
            </tr>
          </thead>
          <tbody>
      `;
    
      for (const o of list) {
        const side =
          o.side === "b" ? "Buy" :
          o.side === "a" ? "Sell" :
          (o.side || "-").toString().toUpperCase();
    
        const rawPx = o.px ?? o.price;
        const px    = Number(rawPx);
        const sz    = Number(o.sz);
        const notional = Number.isFinite(px) && Number.isFinite(sz) ? px * sz : null;
    
        const ts = o.ts ? formatDateTime(o.ts) : "-";
    
        const pxDisplay = formatTokenPrice(rawPx);
    
        html += `
          <tr>
            <td>${o.coin ?? "-"}</td>
            <td>${side}</td>
            <td>${pxDisplay || "-"}</td>
            <td>${Number.isFinite(sz) ? sz.toFixed(2) : "-"}</td>
            <td>${Number.isFinite(notional) ? "$" + formatNumber(notional, 2) : "-"}</td>
            <td>${ts}</td>
          </tr>
        `;
      }
    
      html += "</tbody></table>";
      container.innerHTML = html;
    }

function setDetailMode(isDetail) {
  const summaryCard = document.getElementById("summary-card");
  const tablesCard = document.getElementById("tables-card");
  const chartCard = document.getElementById("chart-card");
  const heroTitle = document.getElementById("hero-title");
  const homeSearchBar = document.getElementById("home-search-bar");
  const detailSummaryRow = document.getElementById("detail-summary-row");

  if (isDetail) {
    // Show detail UI
    if (summaryCard) summaryCard.style.display = "";
    if (tablesCard) tablesCard.style.display = "";
    if (chartCard) chartCard.style.display = "";

    // Update title
    if (heroTitle) heroTitle.textContent = "Account detail view";

    // Hide home search bar
    if (homeSearchBar) homeSearchBar.style.display = "none";

    // Show summary/cashflow row in the top card
    if (detailSummaryRow) detailSummaryRow.style.display = "grid";

  } else {
    // Hide detail UI
    if (summaryCard) summaryCard.style.display = "none";
    if (tablesCard) tablesCard.style.display = "none";
    if (chartCard) chartCard.style.display = "none";

    // Update title
    if (heroTitle) heroTitle.textContent = "Scan a Hyperliquid account";

    // Show home search bar
    if (homeSearchBar) homeSearchBar.style.display = "flex";

    // Hide summary/cashflow row again on home
    if (detailSummaryRow) detailSummaryRow.style.display = "none";
  }
}

function setActiveTable(table) {
  activeTab = table;

  const blocks = {
    positions: "positionsBlock",
    closed: "closedBlock",
    orders: "ordersBlock",      // üîπ new
    cash: "cashBlock",
  };

  const labels = {
    positions: "Open positions",
    closed: "Closed trades",
    orders: "Open orders",      // üîπ new
    cash: "Deposits / withdrawals",
  };

  // Toggle block visibility + active pill
  for (const key of Object.keys(blocks)) {
    const block = document.getElementById(blocks[key]);
    const tabBtn = document.getElementById("tab-" + key);

    if (block) {
      block.style.display = key === table ? "" : "none";
    }
    if (tabBtn) {
      tabBtn.classList.toggle("tab-pill-active", key === table);
    }
  }

  const titleEl = document.getElementById("activeTableTitle");
  if (titleEl && labels[table]) {
    titleEl.textContent = labels[table];
  }
}

function updateDirectionalBias(data) {
  const bar        = document.getElementById("directionalBiasBar");
  const longSeg    = document.getElementById("directionalBiasLong");
  const shortSeg   = document.getElementById("directionalBiasShort");
  const longLabel  = document.getElementById("directionalBiasLongLabel");
  const shortLabel = document.getElementById("directionalBiasShortLabel");
  const metaEl     = document.getElementById("directionalBiasMeta");

  if (!bar || !longSeg || !shortSeg || !longLabel || !shortLabel || !metaEl) {
    return;
  }

  const db = data && data.directionalBias ? data.directionalBias : null;

  // Helper to reset UI to "no data"
  function showNoData() {
    bar.style.visibility = "hidden";
    longSeg.style.width  = "0%";
    shortSeg.style.width = "0%";
    longLabel.textContent  = "Long --%";
    shortLabel.textContent = "Short --%";
    metaEl.textContent = "No fully closed trades in this period.";
  }

  if (!db || typeof db !== "object") {
    showNoData();
    return;
  }

  // --- Determine long/short fractions in [0,1] ---

  let longFrac  = null;
  let shortFrac = null;

  // 1) New contract: ratio + bias ("long" / "short" / "neutral")
  if (typeof db.ratio === "number") {
    // ratio is long share; backend also gives db.bias but we don't strictly need it
    longFrac = Math.max(0, Math.min(1, db.ratio));
    shortFrac = 1 - longFrac;

  // 2) Old fields: biasLong / biasShort
  } else if (typeof db.biasLong === "number" || typeof db.biasShort === "number") {
    const bL = Math.max(0, Number(db.biasLong  ?? 0));
    const bS = Math.max(0, Number(db.biasShort ?? 0));
    const sum = bL + bS;
    if (sum > 0) {
      longFrac  = bL / sum;
      shortFrac = bS / sum;
    }

  // 3) From notionals only: longNotional / shortNotional
  } else if (db.longNotional != null || db.shortNotional != null) {
    const nL = Math.max(0, Number(db.longNotional  ?? 0));
    const nS = Math.max(0, Number(db.shortNotional ?? 0));
    const total = nL + nS;
    if (total > 0) {
      longFrac  = nL / total;
      shortFrac = nS / total;
    }
  }

  if (
    longFrac === null ||
    shortFrac === null ||
    !Number.isFinite(longFrac) ||
    !Number.isFinite(shortFrac)
  ) {
    showNoData();
    return;
  }

  // Clamp again for safety
  longFrac  = Math.max(0, Math.min(1, longFrac));
  shortFrac = Math.max(0, Math.min(1, shortFrac));

  // If both are ~0, treat as no data
  if (longFrac === 0 && shortFrac === 0) {
    showNoData();
    return;
  }

  // --- Convert to % ---
  const longPct  = longFrac * 100;
  const shortPct = shortFrac * 100;

  bar.style.visibility = "visible";

  // Bar segments
  longSeg.style.width  = longPct.toFixed(1) + "%";
  shortSeg.style.width = shortPct.toFixed(1) + "%";

  // Labels
  longLabel.textContent  = `Long ${formatNumber(longPct, 1)}%`;
  shortLabel.textContent = `Short ${formatNumber(shortPct, 1)}%`;

  // --- Meta line with notionals if available ---
  const longNotional  = Number(db.longNotional  ?? 0);
  const shortNotional = Number(db.shortNotional ?? 0);

  if ((longNotional > 0 || shortNotional > 0) && Number.isFinite(longNotional) && Number.isFinite(shortNotional)) {
    const longStr  = "$" + formatNumber(longNotional, 0);
    const shortStr = "$" + formatNumber(shortNotional, 0);
    metaEl.textContent = `Closed long ~${longStr} ¬∑ Closed short ~${shortStr}`;
  } else {
    // fallback text
    metaEl.textContent =
      "Based on realized volume from fully closed trades only.";
  }
}

  function formatEquityLabel(ts, range) {
    const d = new Date(ts);
    if (range === "1d") {
      return d.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit" });
    }
    return d.toLocaleDateString(undefined, { month: "short", day: "numeric" });
  }

  // Map UI range -> backend ?period=
  function mapRangeToPeriod(range) {
    if (range === "1d") return "day";       // HL perpDay (13 points)
    if (range === "7d") return "week";      // HL perpWeek
    if (range === "30d") return "month";    // HL perpMonth
    if (range === "90d") return "90d";      // custom rolling 90d from perpAllTime
    return "allTime";                       // default = full history
  }

    function updateChartSubtitle() {
    const sub = document.getElementById("chart-subtitle");
    if (!sub) return;

    if (activeChartMode === "pnl") {
      sub.textContent = "Realized + funding PnL for this window.";
    } else {
      sub.textContent = "Perp account value over time for this window.";
    }
  }

  function renderEquityChart(range) {
    const card = document.getElementById("chart-card");
    const hasEquity = Array.isArray(equitySeriesAll) && equitySeriesAll.length > 0;
    const hasPnl = Array.isArray(pnlSeriesAll) && pnlSeriesAll.length > 0;

    // Nothing to show
    if (!hasEquity && !hasPnl) {
      if (card) card.style.display = "none";
      return;
    }
    if (card) card.style.display = "";

    // Choose source series based on chart mode
    let source = [];
    if (activeChartMode === "pnl" && hasPnl) {
      source = pnlSeriesAll.map(pt => ({ ts: pt.ts, value: pt.pnl }));
    } else if (activeChartMode === "balance" && hasEquity) {
      source = equitySeriesAll.map(pt => ({ ts: pt.ts, value: pt.equity }));
    }

    // Fallback: if selected mode has no data, switch to the other
    if (!source.length) {
      if (hasEquity) {
        activeChartMode = "balance";
        source = equitySeriesAll.map(pt => ({ ts: pt.ts, value: pt.equity }));
      } else if (hasPnl) {
        activeChartMode = "pnl";
        source = pnlSeriesAll.map(pt => ({ ts: pt.ts, value: pt.pnl }));
      }
    }

    if (!source.length) {
      if (card) card.style.display = "none";
      return;
    }

    // Backend already returns the correct window based on ?period.
    // For example:
    //   period=day   ‚Üí 1D series
    //   period=week  ‚Üí 7D series
    //   period=month ‚Üí 30D series
    //   period=90d   ‚Üí 90D rolling
    //   period=allTime ‚Üí full history
    //
    // So we do NOT slice by time again here ‚Äì we just use the series as-is.
    const dayMs = 24 * 60 * 60 * 1000;

    const filtered = source.slice();  // shallow copy
    const totalSpan =
      filtered.length >= 2
        ? filtered[filtered.length - 1].ts - filtered[0].ts
        : 0;

    const labelRange =
      range === "1d" || totalSpan <= dayMs ? "1d" : range;

    const labels = filtered.map(p => formatEquityLabel(p.ts, labelRange));
    const values = filtered.map(p => p.value);

    // --- Update live value label (top-right) ---
    const liveEl = document.getElementById("chart-live-value");
    if (liveEl) {
      // make sure the container itself never carries color classes
      liveEl.classList.remove("chart-live-positive", "chart-live-negative");

      if (values.length) {
        const lastVal = values[values.length - 1];

        // Range label: All / 1D / 7D / 30D / 90D
        let rangeLabel = "All";
        if (range === "1d") rangeLabel = "1D";
        else if (range === "7d") rangeLabel = "7D";
        else if (range === "30d") rangeLabel = "30D";
        else if (range === "90d") rangeLabel = "90D";

        // Text label depends on mode
        const modeLabel =
          activeChartMode === "pnl" ? "PnL (Perp)" : "Perp balance";

        const absText = "$" + formatNumber(Math.abs(lastVal), 2);
        const sign = lastVal >= 0 ? "" : "-";

        const numberClass =
          lastVal > 0 ? "chart-live-positive"
          : lastVal < 0 ? "chart-live-negative"
          : "";

        // Use HTML so only the number span gets the color class
        liveEl.innerHTML =
          `${rangeLabel} ${modeLabel} ` +
          `<span class="chart-live-number ${numberClass}">${sign}${absText}</span>`;
      } else {
        liveEl.textContent = "";
      }
    }

    // Decide line color based on performance (up = green, down = red)
    let lineColor, fillColor;
    if (values.length >= 2) {
      const firstVal = values[0];
      const lastVal  = values[values.length - 1];
      const isUp = lastVal >= firstVal;

      lineColor = isUp
        ? "rgba(34,197,94,1)"      // green
        : "rgba(239,68,68,1)";     // red

      fillColor = isUp
        ? "rgba(34,197,94,0.15)"
        : "rgba(239,68,68,0.15)";
    } else {
      // Fallback neutral if we only have one point
      lineColor = "rgba(148,163,184,1)";
      fillColor = "rgba(148,163,184,0.15)";
    }

    const ctx = document.getElementById("equityChart").getContext("2d");

    const labelText = activeChartMode === "pnl" ? "Perp PnL" : "Perp balance";
    const tooltipPrefix = activeChartMode === "pnl"
      ? "PnL: $"
      : "Perp balance: $";

    if (equityChart) {
      equityChart.data.labels = labels;
      equityChart.data.datasets[0].data = values;
      equityChart.data.datasets[0].label = labelText;
      equityChart.data.datasets[0].borderColor = lineColor;
      equityChart.data.datasets[0].backgroundColor = fillColor;

      equityChart.options.plugins.tooltip.callbacks.label = function (ctx) {
        return tooltipPrefix + formatNumber(ctx.parsed.y, 2);
      };

      equityChart.update();
    } else {
      // Animation: draw line from left to right
      const totalDuration = 1500; // ms for full draw
      const delayBetweenPoints = values.length
        ? totalDuration / values.length
        : 0;

      const animation = {
        x: {
          type: "number",
          easing: "linear",
          duration: delayBetweenPoints,
          from: NaN,
          delay(ctx) {
            if (ctx.type !== "data" || ctx.xStarted) return 0;
            ctx.xStarted = true;
            return ctx.dataIndex * delayBetweenPoints;
          },
        },
        y: {
          type: "number",
          easing: "linear",
          duration: delayBetweenPoints,
          from(ctx) {
            if (ctx.type !== "data") return 0;
            if (ctx.dataIndex === 0) {
              // start from first value
              return ctx.chart.scales.y.getPixelForValue(values[0]);
            }
            const prevPoint = ctx.chart
              .getDatasetMeta(ctx.datasetIndex)
              .data[ctx.dataIndex - 1];
            return prevPoint.getProps(["y"], true).y;
          },
          delay(ctx) {
            if (ctx.type !== "data" || ctx.yStarted) return 0;
            ctx.yStarted = true;
            return ctx.dataIndex * delayBetweenPoints;
          },
        },
      };

      equityChart = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: [
            {
              label: labelText,
              data: values,
              borderWidth: 2,
              pointRadius: 0,          // üëà hide points by default
              pointHoverRadius: 4,     // üëà show a dot on hover
              pointHitRadius: 8,       // easier to hover
              tension: 0.25,
              borderColor: lineColor,
              backgroundColor: fillColor,
              fill: false,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation, // üëà the left-to-right draw animation
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: function (ctx) {
                  return tooltipPrefix + formatNumber(ctx.parsed.y, 2);
                },
              },
            },
          },
          scales: {
            x: {
              ticks: { maxTicksLimit: 6 },
              grid: { display: false },
              border: { display: false },  // no bottom axis line
            },
            y: {
              ticks: {
                maxTicksLimit: 5,
                callback: (value) => formatNumber(value, 0),
              },
              grid: { display: false },    // no horizontal grid lines
              border: { display: false },  // no left axis line
            },
          },
        },
      });
    }

    // Highlight active range button
    document.querySelectorAll(".range-btn").forEach(btn => {
      if (btn.dataset.range === range) {
        btn.classList.add("range-btn-active");
      } else {
        btn.classList.remove("range-btn-active");
      }
    });

    // Keep subtitle in sync (PnL vs balance)
    updateChartSubtitle();
  }

  function renderRoeCard(roiObj, balances, tradingPnl, period) {
  const summaryCard   = document.getElementById("summary-card");
  const roeValueEl    = document.getElementById("roeValue");
  const roeRangeLabel = document.getElementById("roeRangeLabel");
  const roeMetaEl     = document.getElementById("roeMeta");

  if (!summaryCard || !roeValueEl || !roeRangeLabel || !roeMetaEl) return;

  // Always show the card in detail mode (setDetailMode already hides on home)
  summaryCard.style.display = "";

  const periodIsAllTime =
    period === "allTime" || period === "perpAllTime";

  const startValueTrading =
    typeof roiObj.start_value_trading === "number"
      ? roiObj.start_value_trading
      : null;

  const tradingPct =
    typeof roiObj.trading_pct === "number"
      ? roiObj.trading_pct
      : null;

  // GATING RULE:
  //   if start_equity < 1   ‚Üí hide ROE
  //   if start_equity < 100 ‚Üí hide ROE (too noisy)
  //   also don't show for allTime
  const showRoe =
    !periodIsAllTime &&
    startValueTrading !== null &&
    startValueTrading >= 100 &&
    tradingPct !== null;

  let roeText = "--";
  let roeColor = "var(--muted)";

  if (showRoe) {
    roeText = formatNumber(tradingPct, 2) + "%";
    roeColor = tradingPct >= 0 ? "var(--success)" : "var(--danger)";
  }

  roeValueEl.textContent = roeText;
  roeValueEl.style.color = roeColor;

  // Window label (uses global currentRange)
  let rangeLabelText = "All time";
  if (currentRange === "1d")       rangeLabelText = "Last 24 hours";
  else if (currentRange === "7d")  rangeLabelText = "Last 7 days";
  else if (currentRange === "30d") rangeLabelText = "Last 30 days";
  else if (currentRange === "90d") rangeLabelText = "Last 90 days";

  roeRangeLabel.textContent = "Return on equity ¬∑ " + rangeLabelText;

  // Meta line
  if (showRoe && startValueTrading !== null && balances.perp_now != null) {
    const startStr = "$" + formatNumber(startValueTrading, 2);
    const nowStr   = "$" + formatNumber(balances.perp_now, 2);

    let metaText = `Start: ${startStr} ¬∑ Now: ${nowStr}`;

    if (typeof tradingPnl === "number") {
      const pnlStr = "$" + formatNumber(tradingPnl, 2);
      metaText += ` ¬∑ Perp PnL: ${tradingPnl >= 0 ? "+" : ""}${pnlStr}`;
    }

    roeMetaEl.textContent = metaText;
  } else {
    roeMetaEl.textContent =
      "ROE is only shown when starting perp equity is at least $100 and not for all-time.";
  }
}

  function renderSummaryBadges(data) {
  const summaryBadges = document.getElementById("summaryBadges");
  const summaryMeta   = document.getElementById("summaryMeta");
  if (!summaryBadges || !summaryMeta) return;

  summaryBadges.innerHTML = "";
  summaryMeta.innerHTML   = "";

  // -------- PnL + ROI badges (left side) --------
  const tradingPnl   = typeof data.perp_pnl === "number" ? data.perp_pnl : null;
  const portfolioPnl = typeof data.balance_change === "number" ? data.balance_change : null;

  const roiObj = data.roi || {};
  const portfolioPct =
    typeof roiObj.portfolio_pct === "number" ? roiObj.portfolio_pct : null;

  const pnlBadges = [];

  if (portfolioPnl !== null) {
    const color = portfolioPnl >= 0 ? "green" : "red";
    pnlBadges.push(
      createBadge(
        "Portfolio PnL",
        "$" + formatNumber(portfolioPnl, 2),
        { color }
      )
    );
  }

  if (tradingPnl !== null) {
    const color = tradingPnl >= 0 ? "green" : "red";
    pnlBadges.push(
      createBadge(
        "Perp PnL",
        "$" + formatNumber(tradingPnl, 2),
        { color }
      )
    );
  }

  if (portfolioPct !== null) {
    const color = portfolioPct >= 0 ? "green" : "red";
    pnlBadges.push(
      createBadge(
        "Portfolio ROI",
        formatNumber(portfolioPct, 2) + "%",
        { color }
      )
    );
  }

  if (!pnlBadges.length) {
    summaryBadges.innerHTML =
      '<span style="font-size:0.78rem; color:var(--muted);">No PnL / ROI fields returned in response.</span>';
  } else {
    pnlBadges.forEach(b => summaryBadges.appendChild(b));
  }

  // -------- Meta badges (right side) --------
  const metaBadges = [];

  // v2.8: fundingSummary is the canonical source for cashflow
  const fundingSummary = data.fundingSummary || null;
  let deposits = null;     // Deposits = totalReceived
  let withdrawals = null;  // Withdrawals = totalPaid

  if (fundingSummary) {
    if (typeof fundingSummary.totalReceived === "number") {
      deposits = fundingSummary.totalReceived;
    }
    if (typeof fundingSummary.totalPaid === "number") {
      withdrawals = fundingSummary.totalPaid;
    }
  }

  // Still allow fees from old summary/meta if they exist
  const anySummary =
    data.summary ||
    data.portfolioSummary ||
    data.portfolio ||
    data.meta ||
    null;

  const fees = anySummary?.fees ?? null;

  if (deposits !== null) {
    metaBadges.push(
      createBadge("Deposits", "$" + formatNumber(deposits, 2))
    );
  }
  if (withdrawals !== null) {
    metaBadges.push(
      createBadge("Withdrawals", "$" + formatNumber(withdrawals, 2))
    );
  }
  if (fees !== null) {
    metaBadges.push(
      createBadge("Fees", "$" + formatNumber(fees, 2))
    );
  }

  const balances = data.balances || {};
  if (balances.perp_now != null) {
    metaBadges.push(
      createBadge("Perp balance now", "$" + formatNumber(balances.perp_now, 2))
    );
  }
  if (balances.portfolio_now != null) {
    metaBadges.push(
      createBadge("Portfolio balance now", "$" + formatNumber(balances.portfolio_now, 2))
    );
  }

  // "Net funding" from fundingSummary
  if (fundingSummary && typeof fundingSummary.netFunding === "number") {
    const nf = fundingSummary.netFunding;
    const color = nf >= 0 ? "green" : "red";
    metaBadges.push(
      createBadge(
        "Net funding",
        "$" + formatNumber(nf, 2),
        { color }
      )
    );
  }

  if (!metaBadges.length) {
    summaryMeta.innerHTML =
      '<span style="font-size:0.78rem; color:var(--muted);">No cashflow / balance meta returned.</span>';
  } else {
    metaBadges.forEach(b => summaryMeta.appendChild(b));
  }
}

  function updateRoeCard(data, period) {
  const summaryCard   = document.getElementById("summary-card");
  const roeValueEl    = document.getElementById("roeValue");
  const roeRangeLabel = document.getElementById("roeRangeLabel");
  const roeMetaEl     = document.getElementById("roeMeta");

  if (!summaryCard || !roeValueEl || !roeRangeLabel || !roeMetaEl) return;

  // Pull ROI + balances from response
  const roiObj   = (data && data.roi) || {};
  const balances = (data && data.balances) || {};

  const periodIsAllTime =
    period === "allTime" || period === "perpAllTime";

  const startValueTrading =
    typeof roiObj.start_value_trading === "number"
      ? roiObj.start_value_trading
      : null;

  const tradingPct =
    typeof roiObj.trading_pct === "number"
      ? roiObj.trading_pct
      : null;

  const tradingPnl =
    typeof data.perp_pnl === "number"
      ? data.perp_pnl
      : null;

  // GATING RULE:
  //   if start_equity < 1   ‚Üí hide ROE
  //   if start_equity < 100 ‚Üí hide ROE (too noisy)
  //   and don't show for allTime
  const showRoe =
    !periodIsAllTime &&
    startValueTrading !== null &&
    startValueTrading >= 100 &&
    tradingPct !== null;

  let roeText  = "--";
  let roeColor = "var(--muted)";

  if (showRoe) {
    roeText  = formatNumber(tradingPct, 2) + "%";
    roeColor = tradingPct >= 0 ? "var(--success)" : "var(--danger)";
  }

  // Card is always visible in detail-mode (because of bias bar),
  // we just decide what the ROE line shows.
  summaryCard.style.display = "";

  roeValueEl.textContent   = roeText;
  roeValueEl.style.color   = roeColor;

  // Window label (uses global currentRange)
  let rangeLabelText = "All time";
  if (currentRange === "1d")       rangeLabelText = "Last 24 hours";
  else if (currentRange === "7d")  rangeLabelText = "Last 7 days";
  else if (currentRange === "30d") rangeLabelText = "Last 30 days";
  else if (currentRange === "90d") rangeLabelText = "Last 90 days";

  roeRangeLabel.textContent = "Return on equity ¬∑ " + rangeLabelText;

  // Meta line
  if (showRoe && startValueTrading !== null && balances.perp_now != null) {
    const startStr = "$" + formatNumber(startValueTrading, 2);
    const nowStr   = "$" + formatNumber(balances.perp_now, 2);

    let metaText = `Start: ${startStr} ¬∑ Now: ${nowStr}`;

    if (tradingPnl !== null) {
      const pnlStr = "$" + formatNumber(tradingPnl, 2);
      metaText += ` ¬∑ Perp PnL: ${tradingPnl >= 0 ? "+" : ""}${pnlStr}`;
    }

    roeMetaEl.textContent = metaText;
  } else {
    roeMetaEl.textContent =
      "ROE is only shown when starting perp equity is at least $100 and not for all-time.";
  }
}


async function runFetch(skipRedirect, rangeOverride, options = {}) {
  const updateTables = options.updateTables !== false; // default true

  const accountInput = document.getElementById("account");
  const statusEl = document.getElementById("status");
  const fetchBtn = document.getElementById("fetchBtn");

  // UI range (graph buttons): all, 90d, 30d, 7d, 1d
  const uiRange = rangeOverride || currentRange || "all";
  currentRange = uiRange;

  // Backend ?period value: day/week/month/allTime/90d
  const period = mapRangeToPeriod(uiRange);

  const account = accountInput.value.trim();

  if (!account) {
    statusEl.textContent = "Please enter an account address.";
    statusEl.className = "status status-error";
    return;
  }

  // URL param handling (account + period)
  const currentUrl = new URL(window.location.href);
  const hasAccountInUrl = !!currentUrl.searchParams.get("account");

  if (!skipRedirect && !hasAccountInUrl) {
    currentUrl.searchParams.set("account", account);
    currentUrl.searchParams.set("period", uiRange); // store UI range in URL
    window.location.href = currentUrl.toString();
    return;
  }

  setDetailMode(true);
  setActiveTable("positions");

  // Hardcoded Worker URL
  let baseUrl = DEFAULT_BASE_URL.replace(/\/+$/, "");
  const url =
    baseUrl +
    "/pnlClean?account=" +
    encodeURIComponent(account) +
    "&period=" +
    encodeURIComponent(period) +
    (updateTables
      ? "&positions=1&closed=1&entry=1&orders=1"
      : "&positions=0&closed=0&orders=0");

    statusEl.textContent = "Fetching from " + url + " ‚Ä¶";
    statusEl.className = "status";
    fetchBtn.disabled = true;

  try {
    const res = await fetch(url, {
      method: "GET",
      headers: { Accept: "application/json" },
    });

    if (!res.ok) {
      const text = await res.text();
      statusEl.textContent = "Request failed: " + res.status + " " + res.statusText;
      statusEl.className = "status status-error";
      console.error("Error response body:", text);
      return;
    }

    const data = await res.json().catch(() => null);
    if (!data) {
      statusEl.textContent = "Received a non-JSON response from the Worker.";
      statusEl.className = "status status-error";
      return;
    }

    // üîπ Keep latest state available for future refactors
    appState.account = account;
    appState.period  = uiRange;   // UI range, e.g. "90d"
    appState.data    = data;
    
    // === [FE BLOCK #1] Analytics: Winrate + Trade Stats =======================
    const analytics = data.analytics || {};
    
    const totalTrades       = analytics.totalTrades       ?? 0;
    const winningTrades     = analytics.winningTrades     ?? 0;
    const losingTrades      = analytics.losingTrades      ?? 0;
    const breakevenTrades   = analytics.breakevenTrades   ?? 0;
    const winRateFraction   = analytics.winRate; // 0‚Äì1 or null
    
    let winRateDisplay = "-";
    if (typeof winRateFraction === "number") {
      const pct = Math.round(winRateFraction * 1000) / 10;
      winRateDisplay = `${pct}%`;
    }
    
    statusEl.textContent = "OK ¬∑ Response received.";
    statusEl.className = "status status-ok";


    // raw JSON block
    const rawBlock = document.getElementById("rawJsonBlock");
    const rawPre = document.getElementById("rawJson");
    rawPre.textContent = JSON.stringify(data, null, 2);
    rawBlock.style.display = "block";

    // account label top-right
    const accountLabel = document.getElementById("accountLabel");
    const accDisplay = (data.account || account || "").toString();
    accountLabel.textContent = accDisplay ? accDisplay.slice(0, 8) + "‚Ä¶" : "";

    // üîπ Summary badges + meta (PnL / ROI / balances)
    renderSummaryBadges(data);

    // üîπ Perp ROE card (left of chart)
    updateRoeCard(data, period);

    // === [FE BLOCK #3A] Apply Winrate to Perp ROE card =========================
    const winrateValueEl = document.getElementById("winrateValue");
    const winrateMetaEl  = document.getElementById("winrateMeta");
  
    if (winrateValueEl) {
      winrateValueEl.textContent = winRateDisplay;   // defined in FE BLOCK #1
    }
  
    if (winrateMetaEl) {
      if (typeof winRateFraction === "number" && totalTrades > 0) {
        winrateMetaEl.textContent =
          `(${totalTrades} trades ‚Äî ${winningTrades} won, ${losingTrades} lost, ${breakevenTrades} breakeven)`;
      } else {
        winrateMetaEl.textContent = "(no closed trades in this window)";
      }
    }

    // üîπ Directional bias (closed trades)
    updateDirectionalBias(data);

    // ---------- TABLES ----------
  if (updateTables) {
    // Plan B: backend now owns these names, no more legacy fallbacks
    const positions = Array.isArray(data.positions) ? data.positions : [];
    const closed    = Array.isArray(data.closed) ? data.closed : [];
  
    const positionsContainer = document.getElementById("positionsTableContainer");
    const closedContainer    = document.getElementById("closedTableContainer");
    const cashContainer      = document.getElementById("cashTableContainer");
  
    // Keep a minimal alias for safety: openOrders ‚Üí orders
    const openOrdersRaw = data.openOrders ?? data.orders;
    const openOrders = Array.isArray(openOrdersRaw) ? openOrdersRaw : [];
  
    // Use backend "now" if available, else browser clock
    const nowMs =
      typeof data.debugWindow?.endMs === "number"
        ? data.debugWindow.endMs
        : Date.now();
  
    // üîπ Build TP/SL coverage map per coin
    const slTpByCoin = buildSlTpByCoin(positions, openOrders);
  
    // üîπ Build tables (positions gets slTpByCoin)
    buildTable(positionsContainer, positions, {
      type: "positions",
      nowMs,
      slTpByCoin,
    });
  
    buildTable(closedContainer, closed, {
      type: "closed",
      nowMs,
    });
  
    // üîπ Open orders tab
    renderOpenOrders(openOrders);

    // üîπ Funding events (perp transfers) ‚Üí cash tab
    const rawFunding = Array.isArray(data.fundingEvents)
      ? data.fundingEvents
      : [];

    fundingEventsAll = rawFunding
      .filter(ev => ev && ev.kind === "perpTransfer")
      .sort((a, b) => {
        const ta = Number(a.time || a.ts || 0);
        const tb = Number(b.time || b.ts || 0);
        return tb - ta; // newest first
      });

    renderFundingTable(cashContainer);

    // üîπ Tab counts
    document.getElementById("positionsCount").textContent = `(${positions.length})`;
    document.getElementById("closedCount").textContent    = `(${closed.length})`;
    document.getElementById("cashCount").textContent      = `(${fundingEventsAll.length})`;
  } // üëà CLOSES: if (updateTables)

  // ---------- CHART SERIES ----------
  // Perp balance series
  equitySeriesAll = Array.isArray(data.equitySeries)
    ? data.equitySeries
    : [];

    if (equitySeriesAll.length) {
      equitySeriesAll = equitySeriesAll
        .map((p) => ({
          ts: Number(p.ts ?? p[0]),
          equity: Number(p.equity ?? p[1]),
        }))
        .filter(
          (p) => Number.isFinite(p.ts) && Number.isFinite(p.equity),
        )
        .sort((a, b) => a.ts - b.ts);
    }

    // Perp PnL series
    pnlSeriesAll = Array.isArray(data.pnlSeries)
      ? data.pnlSeries
      : [];

    if (pnlSeriesAll.length) {
      pnlSeriesAll = pnlSeriesAll
        .map((p) => ({
          ts: Number(p.ts ?? p[0]),
          pnl: Number(p.pnl ?? p[1]),
        }))
        .filter(
          (p) => Number.isFinite(p.ts) && Number.isFinite(p.pnl),
        )
        .sort((a, b) => a.ts - b.ts);
    }

    // üîπ Finally render the unified chart (PnL or balance)
    renderEquityChart(currentRange);

  } catch (err) {
    console.error(err);
    statusEl.textContent = "Error: " + (err?.message || err);
    statusEl.className = "status status-error";
  } finally {
    fetchBtn.disabled = false;
  }
}  // üëà CLOSES: async function runFetch(...)

function handleSubmit(event) {
  if (event) event.preventDefault();
  // First manual fetch: use whatever currentRange is (default = "all")
  runFetch(false, currentRange, { updateTables: true });
}

document.addEventListener("DOMContentLoaded", () => {
  const params = new URLSearchParams(window.location.search);
  const accountParam = params.get("account");
  const periodParam = params.get("period");

  const accountInput = document.getElementById("account");

  if (accountParam) accountInput.value = accountParam;

  if (periodParam && ["all","90d","30d","7d","1d"].includes(periodParam)) {
    currentRange = periodParam;
  }

  // üîπ Home search bar ‚Üí trigger topbar search
  const homeSearchBtn = document.getElementById("homeSearchBtn");
  if (homeSearchBtn) {
    homeSearchBtn.addEventListener("click", () => {
      const val = document.getElementById("homeAccount").value.trim();
      if (!val) return;

      document.getElementById("account").value = val;
      handleSubmit(); // run the PnL fetch
    });
  }

  // üîπ Topbar search form
  document.getElementById("query-form").addEventListener("submit", handleSubmit);

  // Load detail page automatically if URL contains ?account=
  if (accountParam) {
    setDetailMode(true);
    setActiveTable("positions");
    runFetch(true, currentRange, { updateTables: true });
  } else {
    setDetailMode(false);
  }

  // Tab switching
  document.getElementById("tab-positions").addEventListener("click", () => setActiveTable("positions"));
  document.getElementById("tab-closed").addEventListener("click", () => setActiveTable("closed"));
  document.getElementById("tab-orders").addEventListener("click", () => setActiveTable("orders"));  // üîπ NEW
  document.getElementById("tab-cash").addEventListener("click", () => setActiveTable("cash"));

  // Chart mode toggle
  const chartTabPnl = document.getElementById("chart-tab-pnl");
  const chartTabBalance = document.getElementById("chart-tab-balance");

  if (chartTabPnl && chartTabBalance) {
    chartTabPnl.addEventListener("click", () => {
      activeChartMode = "pnl";
      chartTabPnl.classList.add("tab-pill-active");
      chartTabBalance.classList.remove("tab-pill-active");
      updateChartSubtitle();
      renderEquityChart(currentRange);
    });

    chartTabBalance.addEventListener("click", () => {
      activeChartMode = "balance";
      chartTabBalance.classList.add("tab-pill-active");
      chartTabPnl.classList.remove("tab-pill-active");
      updateChartSubtitle();
      renderEquityChart(currentRange);
    });
  }

  // Range buttons (1D / 7D / 30D / etc)
  document.querySelectorAll(".range-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      const range = btn.dataset.range;
      currentRange = range;
      runFetch(true, range, { updateTables: false });
    });
  });
});
</script>
</body>
</html>
